import * as fs from 'fs';

import type { ColorGroup, SemanticToken } from './types.js';

/**
 * Generates a Panda CSS config file with OKLCH colors.
 *
 * @param outputPath - Path where the config file will be written
 * @param colorGroups - Array of global color groups
 * @param lightTokens - Array of light mode semantic tokens
 * @param darkTokens - Array of dark mode semantic tokens
 */
export function generatePandaConfig(
  outputPath: string,
  colorGroups: ColorGroup[],
  lightTokens: SemanticToken[],
  darkTokens: SemanticToken[],
): void {
  const lines: string[] = [];

  // Header comment
  lines.push('/**');
  lines.push(' * Auto-generated by build.ts');
  lines.push(' * DO NOT EDIT MANUALLY');
  lines.push(' * ');
  lines.push(' * Source of truth: src/colors/README.md');
  lines.push(' * To update colors, modify README.md and run: npm run build');
  lines.push(' */');
  lines.push('');
  lines.push('/* eslint-disable import/no-unresolved, @typescript-eslint/no-unsafe-call */');
  lines.push("import { defineConfig } from '@pandacss/dev'");
  lines.push('');
  lines.push('export default defineConfig({');
  lines.push('  theme: {');
  lines.push('    extend: {');
  lines.push('      tokens: {');
  lines.push('        colors: {');

  // Generate global colors as nested objects
  for (const group of colorGroups) {
    const groupName = group.groupName.toLowerCase();
    lines.push(`          ${groupName}: {`);

    for (const color of group.colors) {
      // Remove group prefix to get the shade number
      const shade = color.name.replace(group.groupName, '').toLowerCase();
      lines.push(`            ${shade}: { value: '${color.oklch}' },`);
    }

    lines.push('          },');
  }

  // Generate semantic tokens with base/_dark structure
  const semanticGroups = groupSemanticTokens(lightTokens, darkTokens);

  for (const [category, tokens] of Object.entries(semanticGroups)) {
    const categoryName = category.toLowerCase();
    lines.push(`          ${categoryName}: {`);

    for (const [tokenName, values] of Object.entries(tokens)) {
      const name = tokenName.toLowerCase();
      lines.push(`            ${name}: {`);
      lines.push('              value: {');
      lines.push(`                base: '${values.light}',`);
      lines.push(`                _dark: '${values.dark}',`);
      lines.push('              },');
      lines.push('            },');
    }

    lines.push('          },');
  }

  lines.push('        },');
  lines.push('      },');
  lines.push('    },');
  lines.push('  },');
  lines.push('})');
  lines.push('');

  fs.writeFileSync(outputPath, lines.join('\n'), 'utf-8');
}

/**
 * Groups semantic tokens by category and token name for light/dark mode pairing.
 *
 * @param lightTokens - Array of light mode semantic tokens
 * @param darkTokens - Array of dark mode semantic tokens
 * @returns Grouped tokens with light and dark values
 */
function groupSemanticTokens(
  lightTokens: SemanticToken[],
  darkTokens: SemanticToken[],
): Record<string, Record<string, { light: string; dark: string }>> {
  const groups: Record<string, Record<string, { light: string; dark: string }>> = {};

  // Create a map for quick lookup
  const darkMap = new Map<string, string>();
  for (const token of darkTokens) {
    const value = token.resolvedOklch || token.resolvedHex || token.value;
    darkMap.set(token.name, value);
  }

  for (const token of lightTokens) {
    const [category, tokenName] = token.path;
    const lightValue = token.resolvedOklch || token.resolvedHex || token.value;
    const darkValue = darkMap.get(token.name) || lightValue;

    if (!groups[category]) {
      groups[category] = {};
    }

    groups[category][tokenName] = {
      light: lightValue,
      dark: darkValue,
    };
  }

  return groups;
}
